{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-a676586d-542e-4bae-a6bf-d14dd0da29fe",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-b4342d5b-2e78-4d83-b5a8-211601167730",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-b9f00391-001a-4636-aa68-256c4dd0b193",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc` function in C++ is used to dynamically allocate memory at runtime. However, it can be a source of vulnerabilities if not used properly. If the size of the memory block to be allocated is not properly validated, it can lead to buffer overflow, memory corruption, or other types of undefined behavior. This can potentially be exploited by an attacker to execute arbitrary code or cause a denial of service.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always validate the size of the memory block before calling `malloc`. Avoid using user-supplied or untrusted data directly as the argument to `malloc`. Also, always check the return value of `malloc` to ensure that the memory allocation was successful.\n\n## Source Code Fix Recommendation\n\nHere is a simple example of how to properly use `malloc`:\n\n```cpp\n#include <stdlib.h>\n\n#define BLOCKSIZE 1024\n\nint main() {\n    void* ptr = malloc(BLOCKSIZE);\n    if (ptr == NULL) {\n        // Handle malloc failure (e.g., by exiting the program).\n        exit(1);\n    }\n\n    // Use ptr...\n\n    free(ptr);\n    return 0;\n}\n```\n\nIn this example, `BLOCKSIZE` is a constant, so there is no risk of buffer overflow. The return value of `malloc` is checked to ensure that the memory allocation was successful.\n\n## Library Dependencies\n\nThe `malloc` function is part of the C standard library, so no additional library dependencies are required.\n\n## References\n\n- [CWE-131: Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-1ec18dda-971f-4dfd-a625-0fb825f23a46",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strncpy` function in C++ is considered unsafe because it does not guarantee null-termination of the destination string when the source string length is greater than or equal to the destination buffer size. This can lead to buffer overflows, which can be exploited to execute arbitrary code, overwrite data, or cause a system crash.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer string handling functions that ensure null-termination of the destination string. In C++, the `std::string` class provides safe string operations. Avoid using C-style string functions in C++ code.\n\n## Source Code Fix Recommendation\n\nReplace the `strncpy` function with the `std::string::copy` method. Here is the fixed code:\n\n```cpp\n#include <string>\n\nstd::string fname;\nchar log_file[256];\n\nif (fname.size() < sizeof(log_file)) {\n    fname.copy(log_file, sizeof(log_file) - 1);\n    log_file[fname.size()] = '\\0';\n} else {\n    // Handle error: fname is too long\n}\n```\n\n## Library Dependencies\n\nThe code example requires the following library:\n\n- `<string>`\n\n## References\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS111237"
                ]
              }
            },
            {
              "id": "glog-9a4282bb-64aa-4f62-a904-a8caf153ff14",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-907cee2b-6db3-4021-bada-151b37590c76",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-9b18da1c-1ae4-4b8b-a8e3-d9ba82a43eec",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function does not check for the size of the destination buffer, which can lead to buffer overflow if the source is larger than the destination. This is a common vulnerability in C++ programming, and can lead to serious security issues such as data corruption, system crashes, and even arbitrary code execution.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source and destination before calling `memcpy`. Alternatively, you can use functions like `strncpy` or `memcpy_s` that take the size of the destination as a parameter and ensure that no overflow occurs.\n\n## Source Code Fix Recommendation\n\nReplace the `memcpy` function with `memcpy_s` which checks for buffer overflow:\n\n```cpp\nmemcpy_s(&(rvs_session[session_idx].property), sizeof(rvs_session[session_idx].property), session_property, sizeof(rvs_session_property_t));\n```\n\n## Library Dependencies\n\nThe `memcpy` function is part of the C Standard Library, so no additional libraries are required for this code to execute properly.\n\n## OWASP and CWE Links\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible. Always ensure to check the validity of the links before using them."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-29760b73-9ca0-4164-8dac-216a6845400b",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `malloc()` function in C is used to dynamically allocate a block of memory. If not used properly, it can lead to vulnerabilities such as buffer overflows, memory leaks, and null pointer dereferencing. In this case, the vulnerability lies in the lack of error checking after the `malloc()` call. If `malloc()` fails to allocate the requested memory, it returns a null pointer. If this null pointer is used in subsequent operations without checking, it can lead to undefined behavior and potential security issues.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always check the return value of `malloc()` to ensure that the memory allocation was successful. If `malloc()` returns a null pointer, handle the error appropriately to prevent undefined behavior.\n\n## Source Code Fix Recommendation\n\nHere is a simple fix for the vulnerability:\n\n```c++\nchar* link_info = (char*) malloc(link_info_sz);\nif (link_info == NULL) {\n    // Handle error\n    fprintf(stderr, \"Memory allocation failed\\n\");\n    exit(1);\n}\n```\n\nIn this code, we check if `malloc()` returns a null pointer. If it does, we print an error message and terminate the program.\n\n## Library Dependencies\n\nThe `malloc()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [CWE-690: Unchecked Return Value to NULL Pointer Dereference](https://cwe.mitre.org/data/definitions/690.html)"
              },
              "properties": {
                "tags": [
                  "DS161085"
                ]
              }
            },
            {
              "id": "glog-6febd716-8b37-4a7b-aeeb-be01e67926a3",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-6cb2cea3-3738-4ad6-b530-54e1a3ace79a",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(data, dataBytes.data(), dataBytes.size())`, there is no check to ensure that the size of `dataBytes` is not larger than the size of `data`. This can lead to a buffer overflow, which can cause the program to crash or behave unpredictably, and may allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. If the data is larger than the buffer, you should either resize the buffer or truncate the data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (dataBytes.size() <= sizeof(data)) {\n    memcpy(data, dataBytes.data(), dataBytes.size());\n} else {\n    // Handle error: dataBytes is too large for data\n}\n```\n\nIn this code, we first check if the size of `dataBytes` is less than or equal to the size of `data`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in some way, such as by throwing an exception or returning an error code.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<vector>`: This library provides the `std::vector` class, which is presumably the type of `dataBytes`.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible. Always refer to the latest OWASP and CWE documentation for the most accurate and up-to-date information."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-79832312-8ee8-4361-931c-b490a2b5e456",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using `srand(time(NULL))` or a fixed value to seed randomness can lead to predictable random number sequences. This is a security vulnerability because attackers can predict the sequence of random numbers generated, which can be exploited in various ways, such as guessing session tokens, cryptographic keys, or other sensitive data that rely on randomness for security.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a more secure source of randomness for seeding. On modern systems, you can use libraries that provide cryptographically secure random number generators. For example, C++11 and later versions offer the `<random>` library, which can be used to generate random numbers securely.\n\n### Source Code Fix Recommendation\n\nInstead of using `srand(time(NULL))`, use the `<random>` library to generate random numbers securely. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and seed the random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code properly, the following library dependencies are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<random>`: For generating random numbers using modern C++ facilities.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS149435"
                ]
              }
            },
            {
              "id": "glog-73c0bab5-d3a1-4841-ab8b-78b227da743f",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(scale, scaleBytes.data(), scaleBytes.size())`, there is no check to ensure that the size of `scaleBytes` is not larger than the size of `scale`. This can lead to a buffer overflow, which can cause the program to crash or behave unpredictably, and may allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the source data and the size of the destination buffer before calling `memcpy`.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (scaleBytes.size() <= sizeof(scale)) {\n    memcpy(scale, scaleBytes.data(), scaleBytes.size());\n} else {\n    // Handle error\n}\n```\n\nIn this fixed code, we first check if the size of `scaleBytes` is less than or equal to the size of `scale`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in a way that is appropriate for the specific program.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<vector>`: This library is required if `scaleBytes` is a `std::vector`.\n\n## OWASP and CWE Links\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-8ed8724f-f812-4ee0-95ad-0221b04e6eee",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `memcpy` function in C++ is used to copy a block of memory from one location to another. This function is vulnerable to buffer overflow attacks if the size of the data being copied is larger than the size of the destination buffer. In the provided code snippet, `memcpy(data, dataBytes.data(), dataBytes.size())`, there is no check to ensure that the size of `dataBytes` is not larger than the size of `data`. This can lead to a buffer overflow, which can cause the program to crash or behave unpredictably, and may allow an attacker to execute arbitrary code.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the data and the size of the buffer before calling `memcpy`. If the data is larger than the buffer, you should either resize the buffer or truncate the data to fit.\n\n## Source Code Fix Recommendation\n\nHere is a recommended fix for the provided code snippet:\n\n```cpp\nif (dataBytes.size() <= sizeof(data)) {\n    memcpy(data, dataBytes.data(), dataBytes.size());\n} else {\n    // Handle error: dataBytes is too large for data\n}\n```\n\nIn this code, we first check if the size of `dataBytes` is less than or equal to the size of `data`. If it is, we proceed with the `memcpy`. If it is not, we handle the error in some way, such as by throwing an exception or returning an error code.\n\n## Library Dependencies\n\nThe provided code snippet requires the following library dependencies:\n\n- `<cstring>`: This library provides the `memcpy` function.\n- `<vector>`: This library provides the `std::vector` class, which is presumably the type of `dataBytes`.\n\n## OWASP Resources\n\n- [Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nPlease note that these links are subject to change and may not always be accessible. Always refer to the latest OWASP and CWE documentation for the most accurate and up-to-date information."
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e47d9989-1684-4d1e-9d8b-980cb9f736c4",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`\\0`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behaviors.\n\n## Mitigation Advice\n\nTo mitigate this issue, always ensure that your strings are null-terminated. Avoid using `strlen()` on strings that may not be null-terminated. Instead, consider using safer alternatives such as `strnlen()`, which takes an additional parameter to specify the maximum number of characters to be examined.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```cpp\n#include <cstring>\n\nconst char* prefix = \"example\";\nsize_t length = strlen(prefix);\n```\n\nUse:\n\n```cpp\n#include <cstring>\n\nconst char* prefix = \"example\";\nsize_t length = strnlen(prefix, MAX_LENGTH);\n```\n\nWhere `MAX_LENGTH` is the maximum expected length of the string.\n\n## Library Dependencies\n\nThe code example requires the `<cstring>` library.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-a676586d-542e-4bae-a6bf-d14dd0da29fe",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Vulnerable/Compromised Hash Algorithm\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "rcqt.so/include/metaPackageInfo.h"
                },
                "region": {
                  "startLine": 42,
                  "startColumn": 61,
                  "endLine": 42,
                  "endColumn": 64,
                  "charOffset": 1911,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "rcqt.so/include/metaPackageInfo.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1911,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "rcqt.so/include/metaPackageInfo.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1911,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-b4342d5b-2e78-4d83-b5a8-211601167730",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Vulnerable/Compromised Hash Algorithm\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "rcqt.so/include/metaPackageInfo.h"
                },
                "region": {
                  "startLine": 83,
                  "startColumn": 23,
                  "endLine": 83,
                  "endColumn": 26,
                  "charOffset": 2842,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "rcqt.so/include/metaPackageInfo.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2842,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "rcqt.so/include/metaPackageInfo.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2842,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-b9f00391-001a-4636-aa68-256c4dd0b193",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "mem.so/src/rvs_memtest.cpp"
                },
                "region": {
                  "startLine": 1197,
                  "startColumn": 44,
                  "endLine": 1197,
                  "endColumn": 61,
                  "charOffset": 39558,
                  "charLength": 17,
                  "snippet": {
                    "text": "malloc(BLOCKSIZE)",
                    "rendered": {
                      "text": "malloc(BLOCKSIZE)",
                      "markdown": "`malloc(BLOCKSIZE)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "mem.so/src/rvs_memtest.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 39558,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-1ec18dda-971f-4dfd-a625-0fb825f23a46",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Detected Use of Prohibited C Function (strncpy)\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/rvsliblogger.cpp"
                },
                "region": {
                  "startLine": 143,
                  "startColumn": 4,
                  "endLine": 143,
                  "endColumn": 54,
                  "charOffset": 4349,
                  "charLength": 50,
                  "snippet": {
                    "text": "strncpy(log_file, fname.c_str(), sizeof(log_file))",
                    "rendered": {
                      "text": "strncpy(log_file, fname.c_str(), sizeof(log_file))",
                      "markdown": "`strncpy(log_file, fname.c_str(), sizeof(log_file))`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/rvsliblogger.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4349,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "strcpy_s(log_file,  sizeof(log_file,  fname.c_str())"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strncpy is dangerous, as if the source contains 'n' or more characters, it will not null terminate the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/rvsliblogger.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4349,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "strlcpy(log_file,  fname.c_str(),  sizeof(log_file)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-9a4282bb-64aa-4f62-a904-a8caf153ff14",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Vulnerable/Compromised Hash Algorithm\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "rcqt.so/src/metaPackageInfo.cpp"
                },
                "region": {
                  "startLine": 43,
                  "startColumn": 78,
                  "endLine": 43,
                  "endColumn": 81,
                  "charOffset": 1719,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "rcqt.so/src/metaPackageInfo.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1719,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "rcqt.so/src/metaPackageInfo.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1719,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-907cee2b-6db3-4021-bada-151b37590c76",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Vulnerable/Compromised Hash Algorithm\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "rcqt.so/include/metaPackageInfo.h"
                },
                "region": {
                  "startLine": 36,
                  "startColumn": 81,
                  "endLine": 36,
                  "endColumn": 84,
                  "charOffset": 1653,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "rcqt.so/include/metaPackageInfo.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1653,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "rcqt.so/include/metaPackageInfo.h"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1653,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-9b18da1c-1ae4-4b8b-a8e3-d9ba82a43eec",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "rvs/src/rvs_interface.cpp"
                },
                "region": {
                  "startLine": 149,
                  "startColumn": 6,
                  "endLine": 149,
                  "endColumn": 99,
                  "charOffset": 4822,
                  "charLength": 93,
                  "snippet": {
                    "text": "memcpy(&(rvs_session[session_idx].property), session_property, sizeof(rvs_session_property_t)",
                    "rendered": {
                      "text": "memcpy(&(rvs_session[session_idx].property), session_property, sizeof(rvs_session_property_t)",
                      "markdown": "`memcpy(&(rvs_session[session_idx].property), session_property, sizeof(rvs_session_property_t)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "rvs/src/rvs_interface.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4822,
                        "charLength": 93
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&(rvs_session[session_idx].property), <size of &(rvs_session[session_idx].property)>,  session_property,  sizeof(rvs_session_property_t)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-29760b73-9ca0-4164-8dac-216a6845400b",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (malloc)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/rvshsa.cpp"
                },
                "region": {
                  "startLine": 1094,
                  "startColumn": 50,
                  "endLine": 1094,
                  "endColumn": 70,
                  "charOffset": 34734,
                  "charLength": 20,
                  "snippet": {
                    "text": "malloc(link_info_sz)",
                    "rendered": {
                      "text": "malloc(link_info_sz)",
                      "markdown": "`malloc(link_info_sz)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If the value provided to malloc is the result of unsafe integer math, it can result in an exploitable condition. "
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/rvshsa.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 34734,
                        "charLength": 20
                      },
                      "insertedContent": {
                        "text": "calloc(<number of elements>, <size of each element>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6febd716-8b37-4a7b-aeeb-be01e67926a3",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Avoid Using Weak or Non-Cryptographic Random Number Generators\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "iet.so/src/iet_worker.cpp"
                },
                "region": {
                  "startLine": 473,
                  "startColumn": 27,
                  "endLine": 473,
                  "endColumn": 32,
                  "charOffset": 14159,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-6cb2cea3-3738-4ad6-b530-54e1a3ace79a",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/rvs_blas.cpp"
                },
                "region": {
                  "startLine": 2404,
                  "startColumn": 13,
                  "endLine": 2404,
                  "endColumn": 60,
                  "charOffset": 75769,
                  "charLength": 47,
                  "snippet": {
                    "text": "memcpy(data, dataBytes.data(), dataBytes.size()",
                    "rendered": {
                      "text": "memcpy(data, dataBytes.data(), dataBytes.size()",
                      "markdown": "`memcpy(data, dataBytes.data(), dataBytes.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/rvs_blas.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 75769,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "memcpy_s(data, <size of data>,  dataBytes.data(),  dataBytes.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-79832312-8ee8-4361-931c-b490a2b5e456",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Avoid seeding randomness using system time or a fixed value."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "iet.so/src/iet_worker.cpp"
                },
                "region": {
                  "startLine": 519,
                  "startColumn": 2,
                  "endLine": 519,
                  "endColumn": 13,
                  "charOffset": 15199,
                  "charLength": 11,
                  "snippet": {
                    "text": "srand(time(",
                    "rendered": {
                      "text": "srand(time(",
                      "markdown": "`srand(time(`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.WeakRandomness"
            ]
          }
        },
        {
          "ruleId": "glog-73c0bab5-d3a1-4841-ab8b-78b227da743f",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/rvs_blas.cpp"
                },
                "region": {
                  "startLine": 2388,
                  "startColumn": 9,
                  "endLine": 2388,
                  "endColumn": 59,
                  "charOffset": 74953,
                  "charLength": 50,
                  "snippet": {
                    "text": "memcpy(scale, scaleBytes.data(), scaleBytes.size()",
                    "rendered": {
                      "text": "memcpy(scale, scaleBytes.data(), scaleBytes.size()",
                      "markdown": "`memcpy(scale, scaleBytes.data(), scaleBytes.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/rvs_blas.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 74953,
                        "charLength": 50
                      },
                      "insertedContent": {
                        "text": "memcpy_s(scale, <size of scale>,  scaleBytes.data(),  scaleBytes.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-8ed8724f-f812-4ee0-95ad-0221b04e6eee",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/rvs_blas.cpp"
                },
                "region": {
                  "startLine": 2385,
                  "startColumn": 9,
                  "endLine": 2385,
                  "endColumn": 56,
                  "charOffset": 74815,
                  "charLength": 47,
                  "snippet": {
                    "text": "memcpy(data, dataBytes.data(), dataBytes.size()",
                    "rendered": {
                      "text": "memcpy(data, dataBytes.data(), dataBytes.size()",
                      "markdown": "`memcpy(data, dataBytes.data(), dataBytes.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/rvs_blas.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 74815,
                        "charLength": 47
                      },
                      "insertedContent": {
                        "text": "memcpy_s(data, <size of data>,  dataBytes.data(),  dataBytes.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e47d9989-1684-4d1e-9d8b-980cb9f736c4",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Issue Detected with C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/gpu_util.cpp"
                },
                "region": {
                  "startLine": 59,
                  "startColumn": 19,
                  "endLine": 59,
                  "endColumn": 33,
                  "charOffset": 2293,
                  "charLength": 14,
                  "snippet": {
                    "text": "strlen(prefix)",
                    "rendered": {
                      "text": "strlen(prefix)",
                      "markdown": "`strlen(prefix)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/gpu_util.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2293,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strlen_s(prefix, <size of prefix>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/gpu_util.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2293,
                        "charLength": 14
                      },
                      "insertedContent": {
                        "text": "strnlen(prefix, <size of prefix>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}